package gago

import (
	"math/rand"
	"sort"
)

// Type specific mutations for slices

// CrossUniformFloat64 crossover combines two individuals (the parents) into one
// (the offspring). Each parent's contribution to the Genome is determined by
// the value of a probability p. Each offspring receives a proportion of both of
// it's parents genomes. The new values are located in the hyper-rectangle
// defined between both parent's position in Cartesian space.
func CrossUniformFloat64(p1 []float64, p2 []float64, rng *rand.Rand) (o1 []float64, o2 []float64) {
	var gSize = len(p1)
	o1 = make([]float64, gSize)
	o2 = make([]float64, gSize)
	// For every gene pick a random number between 0 and 1
	for i := 0; i < gSize; i++ {
		var p = rng.Float64()
		o1[i] = p*p1[i] + (1-p)*p2[i]
		o2[i] = (1-p)*p1[i] + p*p2[i]
	}
	return o1, o2
}

// Generic mutations for slices

// CrossNPoint applies n-point crossover to two parents (p1 and p2) in order
// two new offsprings (o1 and o2). An identical point is chosen on each parent's
// genome and the mirroring segments are switched. The n parameter can be
// used to determine the number of crossovers (aka mirroring segments) to
// perform. n has to be equal or lower than the number of genes in each parent.
func CrossNPoint(p1 []interface{}, p2 []interface{}, n int, rng *rand.Rand) (o1 []interface{}, o2 []interface{}) {
	// Choose n random points along the genome
	var (
		k      = len(p1) // Genome size
		points = randomInts(n, 1, k, rng)
		s      = true // Use a switch to know which parent to copy onto each offspring
	)
	o1 = make([]interface{}, k)
	o2 = make([]interface{}, k)
	sort.Ints(points)
	// Add the start and end of the genome points
	points = append([]int{0}, points...)
	points = append(points, k)
	for i := 0; i < len(points)-1; i++ {
		if s {
			copy(o1[points[i]:points[i+1]], p1[points[i]:points[i+1]])
			copy(o2[points[i]:points[i+1]], p2[points[i]:points[i+1]])
		} else {
			copy(o1[points[i]:points[i+1]], p2[points[i]:points[i+1]])
			copy(o2[points[i]:points[i+1]], p1[points[i]:points[i+1]])
		}
		s = !s // Alternate for the new copying
	}
	return
}

// CrossNPointFloat64 is a convenience function for calling CrossNPoint on a
// float64 slice.
func CrossNPointFloat64(v1 []float64, v2 []float64, n int, rng *rand.Rand) ([]float64, []float64) {
	var (
		p1, p2 = uncastFloat64s(v1), uncastFloat64s(v2)
		o1, o2 = CrossNPoint(p1, p2, n, rng)
	)
	return castFloat64s(o1), castFloat64s(o2)
}

// CrossNPointInt is a convenience function for calling CrossNPoint on an int
// slice.
func CrossNPointInt(v1 []int, v2 []int, n int, rng *rand.Rand) ([]int, []int) {
	var (
		p1, p2 = uncastInts(v1), uncastInts(v2)
		o1, o2 = CrossNPoint(p1, p2, n, rng)
	)
	return castInts(o1), castInts(o2)
}

// CrossNPointString is a convenience function for calling CrossNPoint on a
// float64 slice.
func CrossNPointString(v1 []string, v2 []string, n int, rng *rand.Rand) ([]string, []string) {
	var (
		p1, p2 = uncastStrings(v1), uncastStrings(v2)
		o1, o2 = CrossNPoint(p1, p2, n, rng)
	)
	return castStrings(o1), castStrings(o2)
}

// CrossPMX (Partially Mapped Crossover) randomly picks a crossover point. The
// offsprings are generated by copying one of the parents and then copying the
// other parent's values up to the crossover point. Each gene that is replaced
// is permuted with the gene that is copied in the first parent's genome. Two
// offsprings are generated in such a way (because there are two parents). This
// crossover method ensures the offspring's genomes are composed of unique
// genes, which is particularly useful for permutation problems such as the
// Traveling Salesman Problem (TSP).
func CrossPMX(p1 []interface{}, p2 []interface{}, rng *rand.Rand) (o1 []interface{}, o2 []interface{}) {
	var gSize = len(p1)
	o1 = make([]interface{}, gSize)
	o2 = make([]interface{}, gSize)
	copy(o1, p1)
	copy(o2, p2)
	// Paste the father's genome up to the crossover point
	for i := 0; i < rng.Intn(gSize-2)+1; i++ {
		// Find where the second parent's gene is in the first offspring's genome
		var a = getIndex(p2[i], o1)
		// Swap the genes
		o1[a], o1[i] = o1[i], p2[i]
		// Find where the first parent's gene is in the second offspring's genome
		var b = getIndex(p1[i], o2)
		// Swap the genes
		o2[b], o2[i] = o2[i], p1[i]
	}
	return o1, o2
}

// CrossPMXFloat64 is a convenience function for calling CrossPMX on a
// float64 slice.
func CrossPMXFloat64(v1 []float64, v2 []float64, n int, rng *rand.Rand) ([]float64, []float64) {
	var (
		p1, p2 = uncastFloat64s(v1), uncastFloat64s(v2)
		o1, o2 = CrossPMX(p1, p2, rng)
	)
	return castFloat64s(o1), castFloat64s(o2)
}

// CrossPMXInt is a convenience function for calling CrossPMX on an int
// slice.
func CrossPMXInt(v1 []int, v2 []int, n int, rng *rand.Rand) ([]int, []int) {
	var (
		p1, p2 = uncastInts(v1), uncastInts(v2)
		o1, o2 = CrossPMX(p1, p2, rng)
	)
	return castInts(o1), castInts(o2)
}

// CrossPMXString is a convenience function for calling CrossPMX on a
// float64 slice.
func CrossPMXString(v1 []string, v2 []string, n int, rng *rand.Rand) ([]string, []string) {
	var (
		p1, p2 = uncastStrings(v1), uncastStrings(v2)
		o1, o2 = CrossPMX(p1, p2, rng)
	)
	return castStrings(o1), castStrings(o2)
}
