package gago

import (
	"math/rand"
	"sort"
)

// Type specific mutations for slices

// CrossUniformFloat64 crossover combines two individuals (the parents) into one
// (the offspring). Each parent's contribution to the Genome is determined by
// the value of a probability p. Each offspring receives a proportion of both of
// it's parents genomes. The new values are located in the hyper-rectangle
// defined between both parent's position in Cartesian space.
func CrossUniformFloat64(p1 []float64, p2 []float64, rng *rand.Rand) (o1 []float64, o2 []float64) {
	var gSize = len(p1)
	o1 = make([]float64, gSize)
	o2 = make([]float64, gSize)
	// For every gene pick a random number between 0 and 1
	for i := 0; i < gSize; i++ {
		var p = rng.Float64()
		o1[i] = p*p1[i] + (1-p)*p2[i]
		o2[i] = (1-p)*p1[i] + p*p2[i]
	}
	return o1, o2
}

// Generic mutations for slices

// Crossover two slices with the same length along a list of ordered indexes.
// This method is a generic n-point crossover where n is the length of the
// indexes argument. This method is deterministic and can easily be tested.
func nPointCrossover(p1, p2 []interface{}, indexes []int) ([]interface{}, []interface{}) {
	var (
		n  = len(p1)
		o1 = make([]interface{}, n)
		o2 = make([]interface{}, n)
		s  = true // Switch
	)
	// Add the first and last indexes
	indexes = append([]int{0}, indexes...)
	indexes = append(indexes, n)
	for i := 0; i < len(indexes)-1; i++ {
		if s {
			copy(o1[indexes[i]:indexes[i+1]], p1[indexes[i]:indexes[i+1]])
			copy(o2[indexes[i]:indexes[i+1]], p2[indexes[i]:indexes[i+1]])
		} else {
			copy(o1[indexes[i]:indexes[i+1]], p2[indexes[i]:indexes[i+1]])
			copy(o2[indexes[i]:indexes[i+1]], p1[indexes[i]:indexes[i+1]])
		}
		s = !s // Alternate for the new copying
	}
	return o1, o2
}

// CrossNPoint applies n-point crossover to two parents (p1 and p2) in order
// two new offsprings (o1 and o2). An identical point is chosen on each parent's
// genome and the mirroring segments are switched. The n parameter can be
// used to determine the number of crossovers (aka mirroring segments) to
// perform. n has to be equal or lower than the number of genes in each parent.
func CrossNPoint(p1 []interface{}, p2 []interface{}, n int, rng *rand.Rand) (o1 []interface{}, o2 []interface{}) {
	// Choose n random points along the genome
	var (
		k      = len(p1) // Genome size
		points = randomInts(n, 1, k, rng)
	)
	sort.Ints(points)
	return nPointCrossover(p1, p2, points)
}

// CrossNPointFloat64 is a convenience function for calling CrossNPoint on a
// float64 slice.
func CrossNPointFloat64(v1 []float64, v2 []float64, n int, rng *rand.Rand) ([]float64, []float64) {
	var (
		p1, p2 = uncastFloat64s(v1), uncastFloat64s(v2)
		o1, o2 = CrossNPoint(p1, p2, n, rng)
	)
	return castFloat64s(o1), castFloat64s(o2)
}

// CrossNPointInt is a convenience function for calling CrossNPoint on an int
// slice.
func CrossNPointInt(v1 []int, v2 []int, n int, rng *rand.Rand) ([]int, []int) {
	var (
		p1, p2 = uncastInts(v1), uncastInts(v2)
		o1, o2 = CrossNPoint(p1, p2, n, rng)
	)
	return castInts(o1), castInts(o2)
}

// CrossNPointString is a convenience function for calling CrossNPoint on a
// float64 slice.
func CrossNPointString(v1 []string, v2 []string, n int, rng *rand.Rand) ([]string, []string) {
	var (
		p1, p2 = uncastStrings(v1), uncastStrings(v2)
		o1, o2 = CrossNPoint(p1, p2, n, rng)
	)
	return castStrings(o1), castStrings(o2)
}

// This method is deterministic and can easily be tested.
func pmxCrossover(p1, p2 []interface{}, a, b int) ([]interface{}, []interface{}) {
	var (
		n  = len(p1)
		o1 = make([]interface{}, n)
		o2 = make([]interface{}, n)
	)
	// Copy part of the first parent's genome onto the first offspring
	copy(o1[a:b], p1[a:b])
	copy(o2[a:b], p2[a:b])
	for i := a; i < b; i++ {
		// Find the element in the the second parent that has not been copied in the first offspring
		if !elementInSlice(p2[i], o1[a:b]) {
			var j = i
			for o1[j] != nil {
				j = getIndex(o1[j], p2)
			}
			o1[j] = p2[i]
		}
		// Find the element in the first the parent that has not been copied in the second offspring
		if !elementInSlice(p1[i], o2[a:b]) {
			var j = i
			for o2[j] != nil {
				j = getIndex(o2[j], p1)
			}
			o2[j] = p1[i]
		}
	}
	// Fill in the offspring's missing values with the opposite parent's values
	for i := 0; i < n; i++ {
		if o1[i] == nil {
			o1[i] = p2[i]
		}
		if o2[i] == nil {
			o2[i] = p1[i]
		}
	}
	return o1, o2
}

// CrossPMX (Partially Mapped Crossover) randomly picks a crossover point. The
// offsprings are generated by copying one of the parents and then copying the
// other parent's values up to the crossover point. Each gene that is replaced
// is permuted with the gene that is copied in the first parent's genome. Two
// offsprings are generated in such a way (because there are two parents). This
// crossover method ensures the offspring's genomes are composed of unique
// genes, which is particularly useful for permutation problems such as the
// Traveling Salesman Problem (TSP).
func CrossPMX(p1 []interface{}, p2 []interface{}, rng *rand.Rand) (o1 []interface{}, o2 []interface{}) {
	var (
		n       = len(p1)
		indexes = randomInts(2, 0, n, rng)
	)
	sort.Ints(indexes)
	var (
		a = indexes[0]
		b = indexes[1]
	)
	o1, o2 = pmxCrossover(p1, p2, a, b)
	return o1, o2
}

// CrossPMXFloat64 is a convenience function for calling CrossPMX on a
// float64 slice.
func CrossPMXFloat64(v1 []float64, v2 []float64, n int, rng *rand.Rand) ([]float64, []float64) {
	var (
		p1, p2 = uncastFloat64s(v1), uncastFloat64s(v2)
		o1, o2 = CrossPMX(p1, p2, rng)
	)
	return castFloat64s(o1), castFloat64s(o2)
}

// CrossPMXInt is a convenience function for calling CrossPMX on an int
// slice.
func CrossPMXInt(v1 []int, v2 []int, n int, rng *rand.Rand) ([]int, []int) {
	var (
		p1, p2 = uncastInts(v1), uncastInts(v2)
		o1, o2 = CrossPMX(p1, p2, rng)
	)
	return castInts(o1), castInts(o2)
}

// CrossPMXString is a convenience function for calling CrossPMX on a
// float64 slice.
func CrossPMXString(v1 []string, v2 []string, n int, rng *rand.Rand) ([]string, []string) {
	var (
		p1, p2 = uncastStrings(v1), uncastStrings(v2)
		o1, o2 = CrossPMX(p1, p2, rng)
	)
	return castStrings(o1), castStrings(o2)
}
